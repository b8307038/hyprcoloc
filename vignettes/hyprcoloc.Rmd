---
title: "HyPrColoc"
author: "Christopher Foley & James Staley"
date: "9/05/2019"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hyprcoloc}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

HyPrColoc is Bayesian divisive clustering algorithm for identifying sets of traits which colocalize at distinct causal variants in a genomic region. The default algorithm can identify clusters of putatively colocalized traits, within a vast collection of traits, e.g. 1000s, quickly. For each set of putatively colocalized traits, the algorithm outputs: the names of the traits, the posterior probability of colocalization, the location of the shared putatively causal variant and a ‘fine-mapping’ probability to quantify evidence supporting the candidate causal variant being the causal variant. 

Traits can be either continuous, e.g. blood pressure, or discrete, e.g. a disease. Basic analyses require information on the summarized effect estimates (i.e. estimated regression coefficients) and their corresponding standard errors, for each snp in the genomic region and each trait under consideration. These should be entered as numeric matrices. If the traits are measured in non-independent studies (i.e. those containing overlapping participants) analyses can be adjusted to account for this. To do this three matrices are required: (i) the pair-wise marginal correlations between the traits; (ii) the pair-wise LD estimates between the snps in the region and; (iii) the pair-wise estimates of the proportion of sample overlap between study participants. We recommend reading our note (below and in more detail our paper) on adjusting analyses to account for correlated summary data and a-priori trait correlation, before doing so in your analyses. 

### Installation

```{r, echo=F}
options(warn=-1)
```

```{r, eval=F}
install.packages("devtools", repos='http://cran.us.r-project.org')
library(devtools)
install_github("jrs95/hyprcoloc")
```

## Getting started

In the first part of this exercise we begin by loading the package and some data needed to run analyses using HyPrColoc. For a given region, a standard analysis requires data from two matrices, of equal size, denoting: (i) a matrix of effect estimates (betas), with the columns denoting the study traits and rows the snps, and; (ii) a matrix of corresponding standard errors (ses).

```{r}
library(hyprcoloc)
betas <- hyprcoloc::test.betas
head(betas)
ses <- hyprcoloc::test.ses
head(ses)
```


### Basic set-up: assuming independce between studies 

By default HyPrColoc assumes that each trait is measured in a distinct study, i.e. that the participants do not overlap between studies, so that between study estimates of regression coefficients (betas) are independent. The function will automatically employ the Bayesian divisive clustering algorithm to identify clusters of colocalized traits. Each study (/trait) will be assigned a name corresponding to their column position and similarly the snps will be assigned names according to row position. To input trait and snp labels we make use of the "trait.names" and "snp.id" variables, e.g.      

```{r}
traits <- paste0("T", 1:dim(betas)[2])
rsid <- rownames(betas)
res <- hyprcoloc(betas, ses, trait.names=traits, snp.id=rsid)
res
```

From the above output we see that HyPrColoc returns:

(i) a set of traits putatively colocalized traits
(ii) the posterior probability of colocalization of these traits
(iii) the 'regional association' probability (which is always > the posterior probability and is deduced from an assessment similar to a PHeWAS assessment)
(iv) a candidate causal variant explaining the shared association 
(v) the proportion of the posterior probability explained by this variant (which represents the HyPrColoc multi-trait fine-mapping probability). 

Moreover, HyPrColoc returns this information for each iteration of the algorithm, in this case it took three iterations to identify that traits 1-5 form a cluster of colocalized traits, traits 6-8 for a separate cluster of colocalized traits and finally that traits 9 and 10 also colocalize. We see that the cluster of traits 1-5 have a posterior probability $1$ of being colocaized, hence the regional association probability is also $1$ and that the candidate snp rs11591147 explains 100\% of the posterior. Thus, there is very strong support that traits 1-5 colocalize and that rs11591147 be taken as the candidate causal snp in the region. While traits 9 and 10 have strong evidence of colocalizing, having a posterior probability of $0.9$, there is weak evidence to support rs7524677 as the causal snp in the region. This example helps to illustrate that: while a cluster of traits can show strong evidence of colocalization the snp most likely to explain colocalization can be ambiguous.

#### Choosing a subset of trait to analyse

We can choose to assess for evidence of colocalization across a subset of the traits in the full sample. For example, let's suppose interest lies in assessing the first two traits only, in this situation we make use of the "trait.subset" variable, e.g.

```{r}
res <- hyprcoloc(betas, ses, trait.names=traits, snp.id=rsid, trait.subset = c("T1","T2"));
res
```

#### Labelling a trait as either continuous or binary in analyses

For technical reasons, analyses have a dependence on whether a trait is continuous or binary. To let HyPrColoc know which traits are continuous (coded 0) or binary (coded 1) we use the 'binary.outcome' variable. For example, suppose the first three traits are binary, then we type 

```{r}
binary.traits = c(1,1,1,rep(0,dim(betas)[2]-3));
res <- hyprcoloc(betas, ses, trait.names=traits, snp.id=rsid, binary.outcomes = binary.traits);
res
```

### Bayesian divisive clustering algorithm

The Bayesian divisive clustering algorithm identifies clusters of colocalized traits in the sample. The algorithm is automatically used When all traits are identified as not sharing a causal variant. For each iteration of the algorithm, the goal is to identify a subset of traits with the greatest evidence of colocalization. HyPrColoc does this using one of two (user defined) approaches: (i) the regional or (ii) alignment selection criterion. The regional selection criterion is computed from a collection of hypotheses which assume that all traits do not colocalize because one of the traits does not have a causal variant in the region. The alignment selection criterion, however, is computed from hypotheses which assume that all traits do not colocalize because one of the traits has a causal variant elsewhere in the region. The alignment selection process searches a much larger amount of the causal configuration space and is thus more computationally expensive (but potentially more robust) than regional selection. Typically, both strategies perform similarly and we therefore chose the regional selection as the default setting. 


#### Assessing differences between the Bayesian divisive clustering criteria

The regional selection criterion:   

```{r}
res <- hyprcoloc(betas, ses, trait.names=traits, snp.id=rsid, bb.selection = "regional");
res
```

The alignment selection criterion:   

```{r}
res <- hyprcoloc(betas, ses, trait.names=traits, snp.id=rsid, bb.selection = "align");
res
```


#### Assessing the influence of prior choice and the regional and alignment theshold parameters

An important feature of the HyPrColoc software is that it allows for some sensitivity to the choice of causal configuration priors to be assessed. Two prior choices are presented: (i) conditionally uniform priors, which assumes that all causal configurations relating to a given hypotheses are equally likely, and; (ii) variant specific prioris, which, for each variant, focuses on tuning the probability that a variant is colocalized with a subset of traits, for all possible subsets.    


##### Conditionally uniform configuration priors:   

```{r}
res <- hyprcoloc(betas, ses, trait.names=traits, snp.id=rsid, uniform.priors = TRUE);
res
```


##### Variant specific configuration priors (default):   

```{r}
res <- hyprcoloc(betas, ses, trait.names=traits, snp.id=rsid, uniform.priors = FALSE);
res
```

##### Evidential strength and the regional and alignment thresholds  

The default regional $P_{R}^{\ast}$ and alignment $P_{A}^{\ast}$ paramter thresholds are dependent on the choice of configuration prior. The default regional threshold and alignment thresholds using conditionally uniform (CU) configuration priors are $P_R^{\ast}=P_{A}^{\ast}=0.7$ whereas for variant specific (VS) priors the thresholds are set to  $P_R^{\ast}=P_{A}^{\ast}=0.5$. Accordingly, the algorithm will deduce that a set of traits are colocalized when  $P_RP_{A}\geq 0.49$ using CU priors and $P_RP_{A}\geq 0.25$ when using VS priors. We do this because CU priors tend to have a slightly increased false positive rate. Note, these parameter choices are a consequence of extensive testing in simulation scenarios, aiming to maximise the true detection rate whilst minimising the number of false positives. We therefore DO NOT recommend reducing either of these parameters. The defaults should be viewed as lower bounds.

If interest lies in identifying sets of colocalized traits above a certain posterior probability, more stringent regional and alignment threshold parameters can be chosen, e.g.

```{r}
res <- hyprcoloc(betas, ses, trait.names=traits, snp.id=rsid, bb.selection = "regional", uniform.priors = FALSE, reg.thresh = 0.8, align.thresh = 0.8);
res
```

#### Switching the algorithm off

We can choose to switch the Bayesian divisive clustering algorithm off and assess whether all traits colocalize. 

```{r}
res <- hyprcoloc(betas, ses, trait.names=traits, snp.id=rsid, bb.alg = FALSE);
res
```

### Analysing correlated traits

When interest lies in identifying colocalization across a set of traits whose summary data are correlated (due to overlapping participants) three additional peices of information are required: (i) a matrix containing the putative correlation between the traits; (ii) a matrix containing the LD between the snps in the region and; (iii) a matrix containing the proprtion of shared participants between each pair of studies. Note the matrix of overlapping sample proportions has diagonal elements set to 1 and off diagonal elements $(i,j)$ denote the proportion of overlap between the $i$'th and $j$'th studies, i.e. if N denotes the total number of overlapping participants and $\{N_{i},N_{j}\}$ denote the numbers of participants in the $i$'th and $j$'th studies respectively, then $N/\left(N_{i}N_{j}\right)$ is the  $(i,j)=(j,i)$ element. As sample overlap information may not always be available, the HyPrColoc default assumes all studies have the same participants.  

#### Important, before going further...

Should analyses be adjusted for observed correlation between study summary data?

It is our recommendation that users first consider whether this is necessary. There are several points to consider. Firstly, traits which are strongly correlated are in general more likely to colocalize. This has two important consequences: (i) whilst special exceptions exist, generally the a-priori probability of colocalization between two strongly correlated traits is necessarily larger than two traits that are weakly correlated, analyses which ignore this are less likely to capture the largest set of traits which are truley colocalized and; (ii) when a subset of traits which are truley colocalized are identified, one or more of the correlated traits can be wrongly identified as not colocalizing due to mathematical subtleties in the processing of the correlation matrices and NOT because of  some underlying biological importance, this has serious consequences on how we draw biological conclusions from correlation adjusted analyses. Secondly, analysing correlated summary data requires much more computing power and time, owing to many rounds of expensive matrix inversion. Finally, in our extensive testing, when wronly assuming independence between study data we found little to no impact on the false positive detection rate in contrast to when correctly assuming independence.  

#### Analysing correlated traits, continued... 

Our command line tool can automatically compute trait correlation (using a tetrachoric correlation technique) and LD information. However, the R-package requires users to have this information to hand. 

```{r}
trait.cor <- hyprcoloc::test.corr
ld.matrix <- hyprcoloc::test.ld
sample.overlap = matrix(1, dim(betas)[2], dim(betas)[2]) # default assumption, hence presented for clarity
```

##### Variant specific priors

```{r}
res <- hyprcoloc(betas, ses, trait.names=traits, snp.id=rsid, trait.cor = trait.cor, ld.matrix = ld.matrix, sample.overlap = sample.overlap, uniform.priors = FALSE);
res
```

##### Conditionally uniform priors

```{r}
res <- hyprcoloc(betas, ses, trait.names=traits, snp.id=rsid, trait.cor = trait.cor, ld.matrix = ld.matrix, sample.overlap = sample.overlap, uniform.priors = TRUE);
res
```

##### Assuming independence (which correctly captures the data generating model)

```{r}
res <- hyprcoloc(betas, ses, trait.names=traits, snp.id=rsid);
res
```
